# main code
# it doesn't pop up in the same canvas
from user301_hPMHbpw1h9_0 import Vector
import simplegui
import random
import time

CANVAS_DIMS = (600, 400)
GRAVITY = -0.5
WIDTH = 500
HEIGHT = 500
def rotAnti(self):
    aux = self.copy()
    self.x = -aux.y
    self.y = aux.y 
    return self
def getProj(self,normal):
    n = normal.copy()
    return n.mult(self.dot(n))
class Tetris:
    start_level = 0
    #setting up the gui stuff
    Twidth = 10
    Theight = 22
    block_size = 20
    WIDTH = 500
    HEIGHT = 500
    frame_width = 16
    frame_height = 22

    #scoring
    num_cleared = 0
    #define initial grid


    # define dictionary to lookup color from grid values
    # define helpers
def draw_block(c,pos,color):
        """ draws a block with position pos on the canvas c """
        c.draw_polygon([[pos[0],pos[1]],[pos[0]+20, \
                        pos[1]],[pos[0]+20, \
                        pos[1]+20],[pos[0], \
                        pos[1]+20]],1,"White",color)

    # define callbacks

def draw(c):
        """ callback for draw handler, draw blocks represented \
             by grid """

        global frame_height
        global block_size
        global pos_list
        global num_cleared
        global score
        global level
        global start_level
        global Twidth
        grid = [[7 for j in range(22)] for i in range(10)]
        color_Dict = {0:"Aqua", 1:"Orange", 2:"Blue", 3:"Purple", \
                    4:"Red", 5:"Lime", 6:"Yellow", 7:"White", \
                    8: "Black"}

        next_piece_offset = [(10-2)*20, (2)*20]
        for i in range(10):
            for j in range(22):
                draw_block(c,[i*20,j*20], color_Dict[grid[i][j]])


class Blocks:

        def __init__(self):
            #0:"I", 1:"L", 2:"J", 3:"T", 4:"Z", 5:"S", 6:"O" 
                #O is a character not an int
            #self.block_dict = {0:"Aqua", 1:"Orange", \
                               #2:"Blue", 3:"Purple", 4:"Red",\
                               #5:"Lime", 6:"Yellow"}
            self.choice = random.randint(0,6) #last number 
                                    #should be 6 and first 0
            self.next_piece = random.randint(0,6)
            self.piece_dict = {0:[[3,0],[4,0],[5,0],[6,0]], \
                                1:[[4,1],[5,1],[6,1],[6,0]], \
                                2:[[4,0],[4,1],[5,1],[6,1]], \
                                3:[[4,1],[5,1],[6,1],[5,0]], \
                                4:[[4,0],[5,0],[5,1],[6,1]], \
                                5:[[5,0],[6,0],[4,1],[5,1]], \
                                6:[[4,0],[5,0],[4,1],[5,1]]}

        def create_piece(self):
            """Puts all 4 blocks together at the initial drop
                zone"""
            self.choice = self.next_piece
            self.next_piece = random.randint(0,6)
            self.piece = self.piece_dict[self.choice]

        def move_piece(self, offset):
            """This function updates the piece's blocks' 
                position the offset is a list with two 
                elements. ex [0,1]"""
            global grid
            tmp = self.piece
            for block_idx in range(len(tmp)):
                self.piece[block_idx] = [tmp[block_idx][0]+\
                                        offset[0], \
                                        tmp[block_idx][1]+\
                                        offset[1]]
            for block in self.piece: #coloring
                grid[block[0]][block[1]] = self.choice



                #coloring
                for pos in self.piece:
                    grid[pos[0]][pos[1]] = self.choice


def check_fall():
        """Checks if the piece can fall"""
        fall = True
        global pos_list
        for pos in pos_list.piece:#seeing if the piece 
                                    #needs to stop
            if pos[1] == 22-1: #seperate to avoid indexing
                                    #errors in the elif
                fall = False
                break
        return fall

class Theme:
        def __init__(self):
            self.last_time = time.time()

        def check_restart(self):
            if time.time() - self.last_time > 48: #0:48 = music length
                self.last_time = time.time()



def my_update():
        """updates the blocks' positions"""
        global pos_list
        global grid
        global song_them
        global num_cleared
        global score
        global level
        global start_level
        
        grid = [[7 for j in range(22)] for i in range(10)]

        lines_bonus = {0:0, 1:40, 2:100, 3:300, 4:1200}

        #finding the lowest block
        #21 is the bottom and 0 is the top
        lowest_val = -1
        lowest_blocks = []
        for pos in pos_list.piece:
            if pos[1] > lowest_val:
                lowest_val = pos[1]
                lowest_blocks = []
                lowest_blocks.append(pos)
            if pos[1] == lowest_val:
                lowest_blocks.append(pos)

        fall = check_fall()

        #move the piece
        if fall == True:
            #update old squares to be white
            for block in pos_list.piece:
                grid[block[0]][block[1]]= 7
            #draws the new piece
            pos_list.move_piece([0,1])

        lose_flag = False
        if fall == False:
            for pos in pos_list.piece:
                if pos[1] == 0:
                    lose_flag = True
                    break

        if lose_flag == False and fall == False:
            remove_lines = check_line()
            num_cleared += len(remove_lines)

            if num_cleared >= (level+1)*10:
                level += 1
            clear_lines(remove_lines)
            pos_list.create_piece()


def check_line():
        global grid
        #populating the list
        remove_lines = []
        for i in range(22):
            remove_lines.append(i)  
        tmp = grid
        for row_idx in range(len(tmp[0])):
            for col_idx in range(len(tmp)):
                if tmp[col_idx][row_idx] == 7:
                    if row_idx in remove_lines:
                        remove_lines.remove(row_idx)

        return remove_lines

def clear_lines(remove_lines):
        """This function clears lines"""
        global grid
        tmp = grid
        for line_num in remove_lines:
            for col_idx in range(len(tmp)):            
                remove_lines.remove(row_idx)

        #updates the grid after the lines are removed
        tmp = grid
    # initialize position of first block
pos_list = Blocks()
pos_list.create_piece()

f = simplegui.create_frame("Tetris Background",\
                                WIDTH, \
                                HEIGHT, 200)
f.set_canvas_background("White")
f.set_draw_handler(draw)

    # create and start timer for block motion
t = simplegui.create_timer(1000.0/(0+1), \
                                        my_update)
t.start()

f.start()


class Player:
    def __init__(self, pos, radius=10):
        self.pos = pos
        self.vel = Vector()
        self.radius = max(radius, 10)
        self.colour = 'White'
        self.graivty = GRAVITY

    def draw(self, canvas):
        if(self.pos.x - self.radius>(WIDTH-50)):
            self.pos.x = (WIDTH-30)-self.radius
            canvas.draw_circle(self.pos.getP(), 30, 10, 'White', 'White')
        elif(self.pos.x + self.radius <(50)):
            self.pos.x = 30 +self.radius
            canvas.draw_circle(self.pos.getP(), 30, 10, 'White', 'White')    
        if(self.pos.y - self.radius > WIDTH-50):
            self.pos.y = (WIDTH-30)-self.radius
            canvas.draw_circle(self.pos.getP(), 30, 10, 'White', 'White')    
        elif(self.pos.y + self.radius <(0)):
            self.pos.y = WIDTH + self.radius
            canvas.draw_circle(self.pos.getP(), 30, 10, 'White', 'White')

        canvas.draw_circle(self.pos.getP(), 30, 10, 'White', 'White')

    def update(self):
        self.pos.add(self.vel)
        self.vel.multiply(0.85)
    

class Platform:
    def __init__(self,point1,point2):
        self.pA = point1
        self.pB = point2 
        #computing the normal line 
        #self.unit = self.pB.copy().sub(self.pA).normalise()
        #normal = self.unit.copy().rotAnti()
        
    
    def distanceVector(self,pos):
        posToA = pos.copy().sub(self.pA)
        return posToA.getProj(self.normal)
    
    def distance(self,player):
        return self.distanceVector(player).length()
        
    
        
        
        
class Keyboard:
    def __init__(self):
        self.right = False
        self.left = False
        self.up = False
        self.space = False

    def keyDown(self, key):
        if (key == simplegui.KEY_MAP['right']):
            self.right = True
            #special
            if (key == simplegui.KEY_MAP['left']):
                self.left = False
                self.right = True

        elif (key == simplegui.KEY_MAP['left']):
            self.left = True
            if (key == simplegui.KEY_MAP['right']):
                self.right = False
                self.left = True

        elif key == simplegui.KEY_MAP['z']:
            self.up = True

        elif key == simplegui.KEY_MAP['space']:
                self.space = True

    def keyUp(self, key):
        if key == simplegui.KEY_MAP['right']:
            self.right = False

        elif key == simplegui.KEY_MAP['left']:
            self.left = False

        elif key == simplegui.KEY_MAP['z']:
            self.up = False

        elif key == simplegui.KEY_MAP['space']:
            self.space = False
            
class Interaction:
    def __init__(self, ball, keyboard, block):
        self.ball = ball
        self.keyboard = keyboard
        self.block = block

    def update(self):
        if self.keyboard.right:
            self.ball.vel.add(Vector(1, 0))
        if self.keyboard.left:
            self.ball.vel.add(Vector(-1, 0))
        if self.keyboard.up:
            self.ball.vel.add(Vector(0,-1))
        if self.keyboard.space:
            self.ball.vel.add(Vector(0,-2))
            print(self.ball.pos.y)
        else:
                self.ball.pos.y+=GRAVITY
       


kbd = Keyboard()
player = Player(Vector(WIDTH/2, HEIGHT-40))
inter = Interaction(player, kbd, Platform)
platform = Platform(Vector(100,100),Vector(200,200))
              
            
def draw(canvas):
    inter.update()
    player.update()
    player.draw(canvas) 

    
frame = simplegui.create_frame('Interactions', WIDTH, HEIGHT)
frame.set_canvas_background('#2C6A6A')
frame.set_draw_handler(draw)
frame.set_keydown_handler(kbd.keyDown)
frame.set_keyup_handler(kbd.keyUp)
frame.start()
